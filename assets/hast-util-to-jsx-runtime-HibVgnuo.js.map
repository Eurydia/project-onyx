{"version":3,"file":"hast-util-to-jsx-runtime-HibVgnuo.js","sources":["../../node_modules/hast-util-to-jsx-runtime/lib/index.js"],"sourcesContent":["/**\n * @import {Identifier, Literal, MemberExpression} from 'estree'\n * @import {Jsx, JsxDev, Options, Props} from 'hast-util-to-jsx-runtime'\n * @import {Element, Nodes, Parents, Root, Text} from 'hast'\n * @import {MdxFlowExpressionHast, MdxTextExpressionHast} from 'mdast-util-mdx-expression'\n * @import {MdxJsxFlowElementHast, MdxJsxTextElementHast} from 'mdast-util-mdx-jsx'\n * @import {MdxjsEsmHast} from 'mdast-util-mdxjs-esm'\n * @import {Position} from 'unist'\n * @import {Child, Create, Field, State, Style} from './types.js'\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\nimport {whitespace} from 'hast-util-whitespace'\nimport {find, hastToReact, html, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport styleToObject from 'style-to-object'\nimport {pointStart} from 'unist-util-position'\nimport {VFileMessage} from 'vfile-message'\n\n// To do: next major: `Object.hasOwn`.\nconst own = {}.hasOwnProperty\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map()\n\nconst cap = /[A-Z]/g\nconst dashSomething = /-([a-z])/g\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\n\nconst tableCellElement = new Set(['td', 'th'])\n\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime'\n\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JSX.Element}\n *   JSX element.\n */\n\nexport function toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options')\n  }\n\n  const filePath = options.filePath || undefined\n  /** @type {Create} */\n  let create\n\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError(\n        'Expected `jsxDEV` in options when `development: true`'\n      )\n    }\n\n    create = developmentCreate(filePath, options.jsxDEV)\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options')\n    }\n\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options')\n    }\n\n    create = productionCreate(filePath, options.jsx, options.jsxs)\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  }\n\n  const result = one(state, tree, undefined)\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(\n    tree,\n    state.Fragment,\n    {children: result || undefined},\n    undefined\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key)\n  }\n\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node)\n  }\n\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key)\n  }\n\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node)\n  }\n\n  if (node.type === 'root') {\n    return root(state, node, key)\n  }\n\n  if (node.type === 'text') {\n    return text(state, node)\n  }\n}\n\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction element(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type = findComponentFromName(state, node.tagName, false)\n  const props = createElementProps(state, node)\n  let children = createChildren(state, node)\n\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !whitespace(child) : true\n    })\n  }\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpressionHast | MdxTextExpressionHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree\n    const expression = program.body[0]\n    assert(expression.type === 'ExpressionStatement')\n\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateExpression(expression.expression)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsmHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateProgram(node.data.estree)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type =\n    node.name === null\n      ? state.Fragment\n      : findComponentFromName(state, node.name, true)\n  const props = createJsxElementProps(state, node)\n  const children = createChildren(state, node)\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {}\n\n  addChildren(props, createChildren(state, node))\n\n  return state.create(node, state.Fragment, props, key)\n}\n\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction text(_, node) {\n  return node.value\n}\n\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node\n  }\n}\n\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0]\n\n    if (value) {\n      props.children = value\n    }\n  }\n}\n\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const fn = isStaticChildren ? jsxs : jsx\n    return key ? fn(type, props, key) : fn(type, props)\n  }\n}\n\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const point = pointStart(node)\n    return jsxDEV(\n      type,\n      props,\n      key,\n      isStaticChildren,\n      {\n        columnNumber: point ? point.column - 1 : undefined,\n        fileName: filePath,\n        lineNumber: point ? point.line : undefined\n      },\n      undefined\n    )\n  }\n}\n\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n  /** @type {string | undefined} */\n  let alignValue\n  /** @type {string} */\n  let prop\n\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop])\n\n      if (result) {\n        const [key, value] = result\n\n        if (\n          state.tableCellAlignToStyle &&\n          key === 'align' &&\n          typeof value === 'string' &&\n          tableCellElement.has(node.tagName)\n        ) {\n          alignValue = value\n        } else {\n          props[key] = value\n        }\n      }\n    }\n  }\n\n  if (alignValue) {\n    // Assume style is an object.\n    const style = /** @type {Style} */ (props.style || (props.style = {}))\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] =\n      alignValue\n  }\n\n  return props\n}\n\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree\n        const expression = program.body[0]\n        assert(expression.type === 'ExpressionStatement')\n        const objectExpression = expression.expression\n        assert(objectExpression.type === 'ObjectExpression')\n        const property = objectExpression.properties[0]\n        assert(property.type === 'SpreadElement')\n\n        Object.assign(\n          props,\n          state.evaluater.evaluateExpression(property.argument)\n        )\n      } else {\n        crashEstree(state, node.position)\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name\n      /** @type {unknown} */\n      let value\n\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (\n          attribute.value.data &&\n          attribute.value.data.estree &&\n          state.evaluater\n        ) {\n          const program = attribute.value.data.estree\n          const expression = program.body[0]\n          assert(expression.type === 'ExpressionStatement')\n          value = state.evaluater.evaluateExpression(expression.expression)\n        } else {\n          crashEstree(state, node.position)\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value\n      }\n\n      // Assume a prop.\n      props[name] = /** @type {Props[keyof Props]} */ (value)\n    }\n  }\n\n  return props\n}\n\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = []\n  let index = -1\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByName = state.passKeys ? new Map() : emptyMap\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    /** @type {string | undefined} */\n    let key\n\n    if (state.passKeys) {\n      const name =\n        child.type === 'element'\n          ? child.tagName\n          : child.type === 'mdxJsxFlowElement' ||\n              child.type === 'mdxJsxTextElement'\n            ? child.name\n            : undefined\n\n      if (name) {\n        const count = countsByName.get(name) || 0\n        key = name + '-' + count\n        countsByName.set(name, count + 1)\n      }\n    }\n\n    const result = one(state, child, key)\n    if (result !== undefined) children.push(result)\n  }\n\n  return children\n}\n\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(state, prop, value) {\n  const info = find(state.schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject =\n      typeof value === 'object' ? value : parseStyle(state, String(value))\n\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject)\n    }\n\n    return ['style', styleObject]\n  }\n\n  return [\n    state.elementAttributeNameCase === 'react' && info.space\n      ? hastToReact[info.property] || info.property\n      : info.attribute,\n    value\n  ]\n}\n\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */\nfunction parseStyle(state, value) {\n  /** @type {Style} */\n  const result = {}\n\n  try {\n    styleToObject(value, replacer)\n  } catch (error) {\n    if (!state.ignoreInvalidStyle) {\n      const cause = /** @type {Error} */ (error)\n      const message = new VFileMessage('Cannot parse `style` attribute', {\n        ancestors: state.ancestors,\n        cause,\n        ruleId: 'style',\n        source: 'hast-util-to-jsx-runtime'\n      })\n      message.file = state.filePath || undefined\n      message.url = docs + '#cannot-parse-style-attribute'\n\n      throw message\n    }\n  }\n\n  return result\n\n  /**\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\n   * property.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function replacer(name, value) {\n    let key = name\n\n    if (key.slice(0, 2) !== '--') {\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4)\n      key = key.replace(dashSomething, toCamel)\n    }\n\n    result[key] = value\n  }\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result\n\n  if (!allowExpression) {\n    result = {type: 'Literal', value: name}\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.')\n    let index = -1\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let node\n\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = isIdentifierName(identifiers[index])\n        ? {type: 'Identifier', name: identifiers[index]}\n        : {type: 'Literal', value: identifiers[index]}\n      node = node\n        ? {\n            type: 'MemberExpression',\n            object: node,\n            property: prop,\n            computed: Boolean(index && prop.type === 'Literal'),\n            optional: false\n          }\n        : prop\n    }\n\n    assert(node, 'always a result')\n    result = node\n  } else {\n    result =\n      isIdentifierName(name) && !/^[a-z]/.test(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n  }\n\n  // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n  if (result.type === 'Literal') {\n    const name = /** @type {keyof JSX.IntrinsicElements} */ (result.value)\n\n    return own.call(state.components, name) ? state.components[name] : name\n  }\n\n  // Assume component.\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result)\n  }\n\n  crashEstree(state)\n}\n\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */\nfunction crashEstree(state, place) {\n  const message = new VFileMessage(\n    'Cannot handle MDX estrees without `createEvaluater`',\n    {\n      ancestors: state.ancestors,\n      place,\n      ruleId: 'mdx-estree',\n      source: 'hast-util-to-jsx-runtime'\n    }\n  )\n  message.file = state.filePath || undefined\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater'\n\n  throw message\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash)\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\n  return to\n}\n\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */\nfunction toCamel(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n"],"names":["stringify","ok","svg","html","find","hastToReact","stringify$1","styleToObject","whitespace","VFileMessage","name","pointStart","own","emptyMap","cap","dashSomething","tableElements","tableCellElement","docs","toJsxRuntime","tree","options","filePath","create","developmentCreate","productionCreate","state","result","one","node","key","element","mdxExpression","mdxJsxElement","mdxEsm","root","text","parentSchema","schema","type","findComponentFromName","props","createElementProps","children","createChildren","child","addNode","addChildren","expression","assert","crashEstree","createJsxElementProps","_","value","jsx","jsxs","fn","jsxDEV","isStaticChildren","point","alignValue","prop","createProperty","style","attribute","objectExpression","property","index","countsByName","count","info","commas","spaces","styleObject","parseStyle","transformStylesToCssCasing","replacer","error","cause","message","toCamel","allowExpression","identifiers","isIdentifierName","place","domCasing","cssCasing","from","transformStyleToCssCasing","to","toDash","$1","$0"],"mappings":"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","x_google_ignoreList":[0]}