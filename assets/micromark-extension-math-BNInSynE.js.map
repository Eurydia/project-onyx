{"version":3,"file":"micromark-extension-math-BNInSynE.js","sources":["../../node_modules/micromark-extension-math/lib/math-flow.js","../../node_modules/micromark-extension-math/lib/math-text.js","../../node_modules/micromark-extension-math/lib/syntax.js"],"sourcesContent":["/**\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: 'mathFlow'\n};\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit('mathFlowFenceSequence');\n    return factorySpace(effects, metaBefore, \"whitespace\")(code);\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit('mathFlowFenceMeta');\n      return metaAfter(code);\n    }\n    if (code === 36) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence');\n    if (self.interrupt) {\n      return ok(code);\n    }\n    return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt({\n      tokenize: tokenizeClosingFence,\n      partial: true\n    }, after, contentStart)(code);\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (initialSize ? factorySpace(effects, beforeContentChunk, \"linePrefix\", initialSize + 1) : beforeContentChunk)(code);\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentChunk(code);\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(effects, beforeSequenceClose, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return sequenceClose(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok(code);\n      }\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, afterSequenceClose, \"whitespace\")(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code);\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {};\n  let single = options_.singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: 'mathText'\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n    let size;\n    /** @type {Token} */\n    let token;\n    return start;\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return sequenceOpen(code);\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code);\n      }\n      effects.exit('mathTextSequence');\n      return between(code);\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return sequenceClose(code);\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return between;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return between;\n      }\n\n      // Data.\n      effects.enter('mathTextData');\n      return data(code);\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = 'mathTextData';\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Extension} from 'micromark-util-types'\n */\n\nimport { mathFlow } from './math-flow.js';\nimport { mathText } from './math-text.js';\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  };\n}"],"names":["factorySpace","markdownLineEnding","mathFlow","tokenizeMathFenced","nonLazyContinuation","tokenizeNonLazyContinuation","effects","ok","nok","self","tail","initialSize","sizeOpen","start","code","sequenceOpen","metaBefore","metaAfter","meta","beforeNonLazyContinuation","after","tokenizeClosingFence","contentStart","beforeContentChunk","contentChunk","size","beforeSequenceClose","sequenceClose","afterSequenceClose","lineStart","mathText","options","single","tokenizeMathText","resolveMathText","previous","token","between","data","events","tailExitIndex","headEnterIndex","index","enter","math"],"mappings":"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","x_google_ignoreList":[0,1,2]}